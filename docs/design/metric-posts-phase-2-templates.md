# Metric Posts Phase 2: Query Templates (Generic Automation)

Last updated: 2026-02-10

This document proposes Phase 2 of the Metric Posts system: turning Data Explorer style queries into reusable, safe templates that can automatically generate Metric Post drafts (charts + text) on a schedule or on “new data ingested” events.

Phase 1 (already implemented) is documented in `docs/design/metric-posts-event-driven.md`.

## Summary

Phase 2 adds:

1. A `MetricPostTemplate` model that stores an allowlisted table, a findMany-safe Prisma query JSON, a chart spec, and an editable LLM prompt.
2. A template runner that can execute templates safely and generate `MetricPost` drafts idempotently.
3. Triggers: “on ingestion” (event-driven) plus optional scheduled runs.
4. A UI for creating, testing, versioning, and operating templates, including run history and failure inspection.

Key principle: this is not “LLM has DB access”. It is “LLM helps propose a safe read query and a chart, but the system enforces strict validation, limits, and tenancy/entitlements”.

## Goals

1. Make metric drafting generic across multiple datasets beyond deliveries.
2. Allow an admin (or later, a tenant user) to create and run templates without code changes.
3. Maintain safety: read-only access, allowlisted tables, query-shape validation, result caps, timeouts, and required filters.
4. Maintain reliability: idempotency, dedupe, run history, and bounded retries.
5. Keep Phase 1 approve-to-publish workflow unchanged.

## Non-Goals

1. A general SQL workbench for arbitrary queries.
2. Arbitrary joins across tables (Prisma relations may exist, but templates should start as single-table reads).
3. Complex, real-time streaming dashboards.
4. A full job queue in the first cut of Phase 2 (optional later).

## Definitions

1. Template
   - A saved recipe: dataset/table + query + chart spec + prompt + trigger rule.
2. Run
   - A single execution attempt of a template, producing a result or an error.
3. Draft
   - A `MetricPost` row created from a template run, pending human approval.

## Design Overview

Phase 2 adds a generic “template runner” loop:

```text
Trigger (ingestion or schedule)
  -> determine which templates should run
  -> for each template: compute target period/window
  -> safe execute query
  -> generate chart PNG
  -> generate post text (LLM) using a visible template prompt
  -> create MetricPost(DRAFT) with links to template/run
  -> admin approves -> Phase 1 publishing path
```

## Data Model (Proposed)

### MetricPostTemplate

Stores the user-configured “recipe”.

Recommended fields:

1. Identity and ownership
   - `id`
   - `name`
   - `enabled` (boolean)
   - `createdAt`, `updatedAt`
   - `createdByUserId` (optional in single-tenant, required in SaaS)
   - `tenantId` (required for SaaS)

2. Query source
   - `table` (canonical Prisma client key, for example `eVMetric`, `batteryMakerMonthly`)
   - `query` (JSON, findMany-safe subset)
   - `requiredFilters` (optional, enforced constraints like `year` bounds)

3. Chart rendering
   - `chartType` (`bar`, `line`, `horizontalBar`)
   - `chartTitleTemplate` (string with placeholders, for example `"{monthName} {year} China EV Deliveries"`)
   - `xField`, `yField`, `groupField` (optional, for deterministic chart extraction)
   - `style` (JSON: fonts, watermark, color palette, label placement, etc)

4. Prompt and generation
   - `postPromptTemplate` (string with placeholders)
   - `defaultHashtags` (string array)
   - `language` (enum or string)

5. Triggering and idempotency
   - `triggerType`:
     - `ON_INGESTION` (default)
     - `SCHEDULED`
     - `MANUAL_ONLY`
   - `scheduleCron` (only when `SCHEDULED`)
   - `dedupeMode`:
     - `PER_PERIOD` (default for monthly data)
     - `PER_RUN`
   - `dedupeKeyTemplate` (optional)
   - `lastGeneratedKey` (string, last successful dedupe key)

### MetricPostTemplateRun

Run history for observability and debugging.

Recommended fields:

1. Identity
   - `id`
   - `templateId`
   - `createdAt`

2. Run context
   - `triggeredBy` (`INGESTION`, `SCHEDULE`, `MANUAL`)
   - `targetKey` (the computed dedupe key, for example `template:<id>:2026-01`)
   - `targetPeriod` (JSON: `{ year, month }` or `{ startDate, endDate }`)

3. Execution outputs
   - `queryUsed` (JSON snapshot)
   - `rowCount`
   - `executionTimeMs`
   - `chartImageUrl` (optional)
   - `contentPreview` (optional short text)
   - `metricPostId` (if a draft was created)

4. Status and errors
   - `status` (`SUCCESS`, `SKIPPED_DEDUPE`, `EMPTY_RESULT`, `FAILED`)
   - `error` (string)

### MetricPost changes (Phase 2)

Phase 1 already has `MetricPost`. Phase 2 should link drafts back to templates:

1. Add optional columns:
   - `templateId`
   - `templateRunId`

These links allow “show me all drafts generated by template X” and enable per-template analytics.

## Template Safety Model

Templates must remain safe for multi-tenant use and resistant to prompt injection.

### Allowlists

1. Allowlisted tables only
   - Reuse `src/lib/query-executor.ts` allowlist.
2. Allowlisted query keys only
   - Only `where`, `orderBy`, `take`, `skip`, `select`, `distinct`.
3. Field allowlist per table (Phase 2 enhancement)
   - Validate `where/orderBy/select` fields are in a per-table allowed set.

### Hard limits

1. `take` clamped (for example 1000)
2. `skip` clamped (for example 5000) to prevent expensive scans
3. Timeout (for example 5s)
4. Require partition filters on large tables
   - For time-series tables, enforce that the query includes at least one of:
     - `year`
     - `year + month/period`
     - `startDate/endDate` style bounds

### No writes, no raw SQL

1. Only Prisma `findMany` on allowlisted clients.
2. Reject `$queryRaw` and similar patterns.
3. Reject nested relation includes in early Phase 2 unless explicitly allowlisted.

## Target Period Detection (“When Should This Run?”)

Phase 2 supports multiple “time axes” depending on the table.

### Common strategies

1. Latest complete month (monthly time series)
   - Same as Phase 1 deliveries logic, but template-specific.
2. Latest available month (no completeness concept)
3. Rolling window (last 30/90 days)
4. Weekly intervals (based on `startDate/endDate` fields)
5. Manual period input (operator chooses the target key in UI)

Recommendation:

1. Start with `PER_PERIOD` dedupe and monthly detection for the major datasets.
2. Add pluggable “target key builders” per table family.

## Dedupe and Idempotency

Deduping must be deterministic and serverless-safe.

### Dedupe key

Default:

1. `template:<templateId>:<targetKey>`
2. `targetKey` examples:
   - `2026-01` (monthly)
   - `2026-W06` (weekly)
   - `2026-02-10` (daily)

### Idempotency gate

Before creating a new draft:

1. Check if a `MetricPost` already exists for `(templateId, targetKey)` or if `MetricPostTemplate.lastGeneratedKey == targetKey`.
2. If yes, return `SKIPPED_DEDUPE` and record a run history row.

### Concurrency control

For serverless concurrency:

1. Use an atomic `updateMany` lock on `MetricPostTemplate` or on a “run lock” row:
   - Condition: `enabled=true` and `lastGeneratedKey != targetKey`
   - Update: set a `lastAttemptKey` + `lastAttemptAt`
2. Only the winner proceeds to create the draft.

## APIs (Proposed)

### Admin CRUD

1. `GET /api/admin/metric-post-templates`
2. `POST /api/admin/metric-post-templates`
3. `GET /api/admin/metric-post-templates/[id]`
4. `PATCH /api/admin/metric-post-templates/[id]`
5. `DELETE /api/admin/metric-post-templates/[id]` (or soft-delete)

### Run and preview

1. `POST /api/admin/metric-post-templates/[id]/run`
   - Input: optional `targetKey` override
   - Output: run status + generated draft id (if created)
2. `POST /api/admin/metric-post-templates/[id]/preview`
   - Executes query and returns:
     - row sample
     - chart preview base64
     - draft text preview
   - Does not persist a `MetricPost` unless explicitly requested

### Cron triggers

1. `GET /api/cron/metric-post-templates`
   - Runs all enabled templates with `triggerType=ON_INGESTION` or scheduled templates due now
2. For ingestion event-driven mode:
   - Append a step to the ingestion workflow to call this endpoint

Security:

1. Protect cron endpoints with `CRON_SECRET`.
2. Protect admin endpoints with auth and role checks.

## UI/UX (Proposed)

### Data Explorer integration

Add “Save as Template”:

1. Source:
   - current table
   - current query JSON
   - chart config
   - current prompt (from Post Composer)
2. UI must show:
   - a name
   - trigger selection
   - dedupe mode and “target key builder”
   - a safety warning if the query is unbounded

### Template management screen

For admins:

1. List templates with:
   - enabled status
   - last run status
   - last generated period
2. Template details:
   - query editor (JSON + SQL preview)
   - chart config editor
   - prompt editor
   - test run button
   - run history table (MetricPostTemplateRun)

### Draft review stays the same

Once a draft exists, approval and publishing follow Phase 1:

1. Draft -> Approve -> Publish (immediate attempt)
2. Backstop cron retries on transient failures

## Observability and Operations

### What to log and store

1. `MetricPostTemplateRun` row for each attempt
2. For failures, store:
   - validation failures
   - timeout
   - empty results
   - chart generation errors
   - LLM errors

### Metrics you want

1. Runs per template per day
2. Drafts generated per template per day
3. Empty result rate
4. Average runtime and DB time
5. LLM usage cost per template

## Tradeoffs

### Why templates (vs hard-coded post types)

Pros:

1. Faster iteration without code deploys.
2. Customers can build their own recurring “reports”.
3. Allows “long tail” datasets to be monetized without product work for each.

Cons:

1. Higher safety burden.
2. Requires a good UX to avoid “template sprawl”.
3. Needs strong observability to avoid silent failures.

### Why Prisma JSON templates (vs raw SQL templates)

Pros:

1. Easier to validate safely.
2. Avoids SQL injection and reduces the blast radius.
3. Works with your existing allowlist executor.

Cons:

1. Less expressive than SQL.
2. Some analytics workflows become awkward without group-by and joins.

## Migration Plan

1. Add Prisma models:
   - `MetricPostTemplate`
   - `MetricPostTemplateRun`
2. Add `templateId` and `templateRunId` to `MetricPost`.
3. Add admin UI screens.
4. Start with a small set of “first party templates” created by you.
5. Add “Save as Template” from Data Explorer once the template runner is stable.

## Phase 2 Acceptance Criteria

1. You can create a template from a Data Explorer query.
2. A template can run manually and produce a chart + draft post text.
3. Cron/ingestion trigger runs templates idempotently (no duplicates per period).
4. Run history shows successes, skips, empties, and failures with actionable errors.
5. Drafts produced by templates can be approved and published via Phase 1 workflow.

